TODO:
    1. 3.4, 3.5, 3.6 look back
    2. 4.2 look back

********************************************** 1. Object Lessons **************************************************
Layout costs for Adding Encapsulation:
    1. Data members are directly contained within each class object;
    2. Function members: one copy only of each non-inline member function is gernerated;
        Each inline function has either zero or one definition of itself generated with module in which it is used.
    3. Virtual function is the primary layout and access-time overheads:
        1> The virual function mechanism in its support of an efficient run-time binding.
        2> A virtual base class in its support of a single, shared instance of a base class occurring multiple times
            with an inheritance hierarchy.
1.1 The C++ Object Model
    1. Nonstatic data members are allocated directly within each class  object.
    2. Static data members are stored outside the individual class object.
    3. Static and nonstatic function members are also hoisted outside the class object.
    4. Virtual funtions are supported in two steps:
        4.1 A table of pointers to virutal functions is generated for each class(virutal table, vtbl).
        4.2 A single pointer to associated virtual table is inserted within each class object(vptr).
            The setting, resetting, and not setting of the vptr is handled automatically through code generated with
                each class constructor, destructor, and copy assignment operator. 
            The type_info object associated with each class 
                in Support of runtime type identification(RTTI) is also addressed within the virtual table, usually
                within the table's first slot.
    Addint Inheritance:
        The original model of virtual base class support added a pointer into the calss object for each associated
            virtual base class. Alternative models have evolved that either introduce a virutal bases class table 
            or augment the existing virual tabls to maintain the location of each virual base calss.
1.3 An Object Distinction
    The C++ language supports polymorphism in the following ways:
        1. Through a set of implicit conversion, such as the conversion of a derived class pointer to a pointer of 
            it's public base type.
        2. Through the virtual function mechanism.
        3. Through the dynamic_case and typeif operator.
            if (circle *pc = dynamic_case<circle *>(pc)) ...
    The primary use of polymorphism is to effect type encapsulation through a shared interface usually defined within
        an abstract base class from which specific subtypes are derived.
    The memory requirement to represent a class object in general are the following:
        1. The accumulated size of its nonstatic data member
        2. Plus any padding(between members or on the aggreaget boundary itself) due to the alignment constrints.
        3. Plus any internally generated overhead to support the virtuals
      
      
********************************************** 2. The Semantics of Constructor ************************************

2.1 Default Constructor Construction
    If there is no user-declared constructor for class X, a default constructor is implicityly declared...
    A constructor is trivial if it is an implicitly declared default constructor...
    
    The Four conditions that default constructor is nontrivial:
        1. Member Class Object with Default Constructor.
            a. Compiler will generate default constructor for Class object which has ojbect member and without
                any constructor.
            b. Compiler will expand user defined contructor which not initialized the ojbect member
        2. Base class with constructor
        3. Class with virutal function
            I. The class ethier declares(or inherits) a virtual function
            II. The class is derived from an inheritance chain in which one or more base classes are virtual. 
            
            The following two class "augmentation" occur during compilation:
                I. A virtual function table is generated and populated with the address of the active virtual functions
                    for that class.
                II. Within each class object, an additional pointer member is synthesized to hold the address of the 
                    associated clas vtbl.
        4. Class with a virutal Base class

    Summary:
        The four above characteristics of a class under which the compiler needs to synthesize a default constructor 
            for a class that declare no constructor at all.
        The synthesized constructor fulfills only an implementation need.

2.2 Copy Constructor Construction
    Copy constructor happens:
        1. When we use =
        2. Pass an object as an argument to parameter of non-reference type
        3. Return an object from a function that has non-reference return type
        4. Brace initialize the elements of an array or elements of aggregate class

    Default Memberwise Initializaion
        If the class does not provide an explicit copy constructor. Each class object initialized with another object
        of its class is initialized by what is called default memberwise initialization.

        A class object can be copied in two way:
            1. By initialization(copy constructor);
            2. By assignment(copy assignment).
        The Standard distinguishes between a trivial and nontrivial copy constructor. It is only nontrivial 
            instance that in practice is synthesized within the program. The criteria for determining whether a 
            copy constructor is trivial is whether the class exhibits bitwise copy semantics.

    Bitwise Copy Semantics -- Notï¼
        When are bitwise copy semantics not exhibited by a class. There are four instances:
            1. When the class contains a member object of a class for which a copy constructor exists
                (either declared by class designer or synthesized by compiler).
            2. When the class is derived from a base class for which a copy constructor exists(either explicity declared
                synthesized by compiler).
            3. When the class declares one or more virtual functions.
            4. When the class is derived from an inheritance chain in which one or more base class are virtual.

    Global objects are guaranteed to have their associated memory "zeroed out" at program start-up. Local objects 
    allocated on the program stack and heap objects allocated on the free-store do not have their associated memory 
    zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.

    Resetting the Virtual Table Pointer
        Recall that two program "augmentations" occur during compilation whenever a class declares one or more virtual
        functions.
            1. A virtual function table that contains the address of each active virtual function associated with that
                class (the vtbl) is generated.
            2. A pointer to the virtual function table is inserted within each class object (the vptr).
    
        Once the compiler introduces a vptr into a class, the affected class no longer exhibits bitwise semantics. 
        Rather, the implementation now needs to synthesize a copy constructor in order to properly initialize the vptr.

    Handling the Virtual Base Class Subobject
        The compiler must synthesize a copy constructor, inserting code to initialize the virtual base class 
        pointer/offset (or simply being sure that it not be reset), performing the necessary memberwise initializations 
        of its members, and other memory tasks.

    The copy between objects of the same level of hierarchy is bitwise copy semantics
        The initialization of one ZooAnimal class object with another or one Bear class object with another is 
        straightforward and could actually be implemented with bitwise copy semantics.


    Summary:
        The four conditions above under which bitwise copy semantics do not hold for a class and the default copy 
        constructor, if undeclared, is considered nontrivial. Under these conditions, the compiler, in the absence of 
        a declared copy constructor, must synthesize a copy constructor in order to correctly implement 
        the initialization of one class object with another.
 
2.3 Program Transformation Semantics
    Explicit Initialization:
        The required program transformation is two-fold:
            1. Each definition is rewritten with the initialization stripped out.
            2. An invocation of the class copy constructor is inserted.

        X x0;                       // May be transfromed to:
        void foo_bar() {            void foo_bar() {
            X x1( x0 );                 X x1, x2, x3;
            X x2 = x0;                  x1.X::X( x0 );
            X x3 = x( x0 );             x2.X::X( x0 );
            // ...                      x3.X::X( x0 );
        }                           }

    Argument Initialization:
        Passing a class object as an argument to a function (or as that function's return value) is equivalent to the 
        following form of initialization:
            X xx = arg; // xx refers to formal argument, foo(X xx);

        1. One implementation strategy is to introduce a temporary object, initialize it with a call of the copy
            constructor, and then pass that temporary object to the function.
        2. The another implementation is to copy construct the actual argument directly onto its place within the 
            function's activation recored on the program stack. Prior to the return of the function, the local object's 
            destructor, if defined, is applied to it. 

    Return Value Initialization:
        X bar() {
            X xx;
            // process xx ...
            return xx;
        }
        Stroustrup's solution in cfront is a two-fold transformation:
            1. Add an additional argument of type reference to the class object. This argument will hold the copy 
                constructed "return value."
            2. Insert an invocation of the copy constructor prior to the return statement to initialize the added 
                argument with the value of the object being returned.
                
        The codes are transformed to:
        void bar( X& __result ) {
            X xx;
            // compiler generated invocation of default constructor
            xx.X::X();
            // ... process xx
            // compiler generated invocation of copy constructor
            __result.X::X( xx );
            return; 
        }

    Optimization at the User Level:

    Optimization at Compiler Level:
        All return statements return the same named value, it is possible for the compiler itself to optimize the
            function by substituting the result arguement for the named return value. This optimization referred to 
            as the Named Return Value(NRV) optimization.

        X bar() {                   bar(X& _result) {
            X xx;                       _result.X::XX();
            // processing xx            // processing...
            return xx;                  return;
        }                           }  

    The Copy Constructor: To Have or To Have Not?

    Summary:
        Also, the compiler optimizes away the copy constructor invocation where possible, replacing the NRV with and 
        additional first argument within which the value is stored directly. 

2.4 Member Initialization List:
    Member Initialization list is used in order for program to compile:
        1. When initialize a reference member
        2. When initialize a const member
        3. When invoking a base or member class constructor with a set of arguments
    The compiler iterates over the initialization list, inserting the initializations in the proper order within the 
        constructor prior to any explicit user code.
    The order in which the list entries are set down is determined by the declaration order of the members within the 
        class declaration.
            class Base {
            public:
                Base(int val) : j(val+1), i(j-1) {} // i is initialized before j 
            private:
                int i, j;
            };

    The compiler iterates over and possibly reorders the initialization list to reflect the declaration order of the 
    members. It inserts the code within the body of the constructor prior to any explicit user code.
  
********************************************** 3. The Semantics of Data *******************************************
    class X {};
    class Y : public virtual X {};
    class Z : public virtual X {};
    class A : public virtual Y, public virtual Z {};
    
    An empty class is never empty, it has an associated size of 1 byte -- a char member inserted by compiler in order
        to allocate unique address for object in memory.

    The size of class Y and class Z on any machine is the interplay of three factors:
        1. Language support overhead. Within the derived class, this overhead is reflect as some form of pointer,
            either virtual base class subojbect or to an associated table within which either the address or offset
            to the virutal base class suboject is stored.
        2. Compiler optimization of recognized special cases. 
        3. Alignment constraints.

    Static data members are maintained within the global data segment of the program and do not affect the size of 
    individual class objects.

3.1 The Binding of A Data Member    
    The analysis of the member function's body is delayed until the entire class declaration is seen. Thus the binding
        of a data member within the body of an inline member function does not occur until the after the entire class
        declaration is seen.

    When the subsequent declaration of the nested type is encountered, the Standard requires that the 
    earlier bindings be flagged as illegal.

3.2 Data Member Layout
    The Standard requires within an access section(private, public, protected) only that the member be set down such 
        that "later members have higher address within a class object".
3.3 Access of Data Member
    Static Data Member:
        1. Each member's access permission and class association is maintained without incurring any space or runtime
            overhead either in the individual class object or in the static data member itself.
        2. A single instance of each class static data member is stored within the data segment of the program. Each
            reference to the static member is internally translated to be a direct reference of that single extern
            instance.
        3. No mater static member is an inherited member of a complex inheritance hierarchy, there is still only a 
            single instance of the member within the program, an its access is direct.
        4. When static data member is invocated by a function, the Standard C++ explicitly require the function should
            be evaluated, although no use is made of its result.
                // foolbar().chunckSize = 250;
                // evaluate expression, discarding result
                (void) foolvar();
                Point3d.chunkSize = 250;
        5. If two classes each declare a static member 'freeList', then placing both of them in the program data segment
            is going to result a name conflict. The compiler resolves this by internally encoding the name of the each
            static data member [name-mangling] to yield a unique program identifier.
    NonStatic Data Member:
        1. Nonstatic data members are stored directly within each class obejct and cannot be accessed except through an 
            explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses
            a nonstatic data member within a member function.
        2. Access of a nonstatic data member requires the addition of the begining address of the class object with
            the offset location of the data member.
                origin._y = 0.0;
                &origin._y == &origin + (&Point3d::_y - 1);
            The offset of each nonstatic data member is known at compilr time, so access of a nonstatic data member is 
                equivalent in performance to that of a C struct member or the member of a nonderived class.
        3. Virtual inheritance introduces an additional level of indirection in the access of its member throuth a 
            base class suboject.
            Point3d *pt3d;  pt3d->_x = 0.0;
            Performs equivalently if _x is a member of a struct, class, single inheritance hierarchy, or multiple inheritance
            hierarchy, but it performs slower if it is a member of virutal base class.
        4. Access a data member through a pointer or class object is significantly different when class is a derived class 
            contianing a virutal base class within its inheritance hirarchy and the member being accesed is an inherited 
            member of that virtual base class. In this case, with pointer, we cannot say with any certainty which class
            type pt address (and therefore we cannot know at compile time the actual offset location of the member),
            so the resolution of the access must be delayed until runtime through an additional indrection.
            But this is not the case with class object, its type is clear, and the offset location of even inherited 
            virutal bases class member are fixed at compile time.
3.4 Inheritance and the Data Member
    Inheritance without Polymorphism
    Addind Polymorphism
    Multiple Inheritance
    Virutal Inheritance
        https://www.nowcoder.com/profile/3669004/note/detail/232803
3.5 Object Member Efficiency
3.6 Poiner to Data Member
    
  
********************************************** 4. The Semantics of Function ***************************************
4.1 Varieties of Member Invocation
    Nonstatic Member Function:
        1. One C++ design criterion is that a nonstatic member function at a minimum must be as efficient as its 
            analogous nonmember function.
        2. The member function is transformed internally to be equivalent to the nonmember instance:
            2.1 Rewrite the signature to insert an additional argument to the member function that provides access 
                to the invoking class object.
                Point3d::magnitude(Point3d *const this)
            2.2 Rewrite each direct access of a nonstatic data member of the class to access the member through the 
                'this' pointer
                {
                    return sqrt(
                        this->_x * this->_x +
                        this->_y * this->_y +
                        this->_z * this->_z
                    );
                }
            2.3 Rewrite the member function into an external function, mangling its name so that it's lexically unique
                within the program:
                extern magningtude_7Point3dFv(register Point3d *const this);
        3. Name Mangling
            In general, member names are made unique by concatenating the name of the member with that of the class.
    Virtual Member Function:
        1. ptr->normalize(); [ internally transformed to >>> (*ptr->vptr[1])(ptr);
        2. magnitude() were a virtual function, its invocation within normalize() would be transformed to:
            // register float mag = magnitude();
            register float mag = (*this->vptpr[2])(this);
            register float mag = Point3d::magnitude();
            register float mag = magnitude_7Point3dFv(this);
    Static Member Function:
        1. Characteristics of static memeber function:
            1.1 without 'this' pointer
            1.2 Cannot directly access the nonstatic members of its class
            1.3 Cannot be declared const, volatitle, virutal
            1.4 Does not need to invoked throuth an object of its class.
        2. Static member functions, by beging this-less and therefore of the same type as an equivalent nonmember
            function.
4.2 Virtual Member Functions:
    In C++ polymorphism "exhibits" itself as the potential addressing of a derived class object through a pointer
        or reference of a public base class.
    Virtual Function Under MI:
    Three cases that the presence of second or subsequent base class affect support of virtual functions:
        1. Derived class virtual function is invoked through a pointer of second base classs.
        2. invocation of the inherited virtual function of the second base class through a derived class pointer.
        3. allows the return type of a virtual function to vary with regard to the base and publicly 
            derived types of an inheritance hierarchy. <P 124 EN>
4.3 Function Efficiency
    A nonmember, static member, and nonstatic member function are internally transformed into equivalent representations.
        So there is no difference inperformance between these three forms.
    Inline expansion not only saves the overhead associated with a function call but also provides additional
        opportunities for program optimization.
4.4 Pointer to Member Functions
    A pointer to member would be no more expensive than a nonmember pointer to function if it weren't for virutal 
        function and multiple inheritance, which complicate both the type and invocation of a pointer to member.
    4.4.1 Supporting Pointer-to-Virtual-Member Functions
        Taking the address of a nonstatic member function yields its address in memory.
        Taking the address of a virtual   member function yields its index into it's associated virtual table.
        
        Evaluation of a pointer-to-member function is complicated by the dual values (nonvirutal and virutal)
            it can hold and by the very different invocation strategies those value require. 
            (((int)pmf) & 127) ? (*pmf)(ptr) : (*ptr->vptr[(int)pmf](ptr));
    4.4.2 Pointer-to-Member Function Under MI
        struct _mptr {                             (ptr->*pmf)();         
            int delta;  // offset of this pointer  (pmf.index < 0) ? (*pmf.addr)(ptr) : (*ptr->vptr[pmf.indx](ptr));
            int index;
            union {
                ptrtofunc   faddr;
                int         v_offset;
            };
        };
4.5 Inline Function
    There are two phases to the handling of an inline function:
        1. The analysis of the function definition to determine the "intrisic inline-ability" of the function.
            If the function is judged non-inlineable, due either to its complexity or its construction, it is turned
            into a static function and definition is generated within the module being compiled.
        2. The actual inline expansion of the funtion at a point of call. This involves arguement evaluation and 
            management of temporaries.
    
    4.5.1 Formal Arguments
        What happens during inline function expasion?
            1. If the actual arguments exhibits a side effect, there will be a tempory ojbect.
            2. If the actual argument is a constant expression, we'd like to evaluated prior to its substitution.
            3. If it is neither a constanct expression nor an expression with side effect, a straight substitution
                of each argument with associated formal argument is carried out.
          inline int min(int a, int b) {return a < b ? a : b; }
          min(va, vb);              // return va < vb ? va : vb;
          min(12, 13);              // return 12 < 13 ? 12 : 13;         
          min(foo(), bar() + 1);    // tmp1 = foo(), tmp2 = bar()+ 1; return tmp1 < tmp2 ? tmp1 : tmp2; 
    4.5.2 Local Variables
        
        
********************************************** 5. Semantics of Construction, Destruction, and Copy ****************
Presence of a Pure Virtual Function
    Pure virtual destructor must be defined by the class designer:
        Every derived class destructor is internally augmented to statically invoke each of its virtual base and
        immediate base class destructor. The absence of a definition of any of the base class destructor in general
        results in a link-time error.